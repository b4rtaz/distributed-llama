#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#define Q80_Q40_BLOCK_SIZE 32
#define N_THREADS 64

#define TILE_SIZE 2

layout(local_size_x = N_THREADS, local_size_y = 1, local_size_z = 1) in;

struct BatchInfo {
    uint inputOffset;
    uint inputSizeX;
    uint outputOffset;
    uint outputSizeX;
};

struct BlockQ80 {
    float16_t d;
    int8_t qs[Q80_Q40_BLOCK_SIZE];
};

struct BlockQ40 {
    float16_t d;
    uint8_t qs[Q80_Q40_BLOCK_SIZE / 2];
};

layout(binding = 0) readonly buffer inputBuffer { BlockQ80 x[]; };
layout(binding = 1) writeonly buffer outputBuffer { float y[]; };
layout(binding = 2) readonly buffer batchInfosBuffer { BatchInfo infos[]; };
layout(binding = 3) readonly buffer weightBuffer { BlockQ40 weight[]; };

shared uint sharedDStart;
shared uint sharedDEnd;
shared uint sharedInputOffset;
shared uint sharedInputSizeX;
shared uint sharedOutputOffset;
shared uint sharedInputSizeXPerThread;
shared float16_t sums[N_THREADS * TILE_SIZE];

void main() {
    const uint threadIndex = gl_LocalInvocationID.x;

    if (threadIndex == 0) {
        const uint nWorkGroups = gl_NumWorkGroups.z;
        const uint batchIndex = gl_WorkGroupID.y;
        const uint workGroupIndex = gl_WorkGroupID.z;

        const BatchInfo info = infos[batchIndex];
        sharedInputOffset = info.inputOffset;
        sharedInputSizeX = info.inputSizeX;
        sharedOutputOffset = info.outputOffset;
        sharedInputSizeXPerThread = (sharedInputSizeX + N_THREADS - 1) / N_THREADS;

        const uint ySlice = info.outputSizeX / nWorkGroups;
        const uint yRest = info.outputSizeX % nWorkGroups;
        sharedDStart = workGroupIndex * ySlice + (workGroupIndex < yRest ? workGroupIndex : yRest);
        sharedDEnd = sharedDStart + ySlice + (workGroupIndex < yRest ? 1 : 0);
    }

    barrier();
    memoryBarrierShared();

    const uint dEnd = sharedDEnd;
    const uint inputOffset = sharedInputOffset;
    const uint inputSizeX = sharedInputSizeX;
    const uint outputOffset = sharedOutputOffset;
    const uint inputSizeXPerThread = sharedInputSizeXPerThread;

    const uint iStart = inputSizeXPerThread * threadIndex;
    const uint iEnd = min(iStart + inputSizeXPerThread, inputSizeX);

    float16_t xTemp[Q80_Q40_BLOCK_SIZE];

    for (uint d = sharedDStart; d < dEnd; d += TILE_SIZE) {
        for (uint dt = 0; dt < TILE_SIZE; dt++) {
            sums[threadIndex * TILE_SIZE + dt] = float16_t(0.0f);
        }

        for (uint i = iStart; i < iEnd; i += TILE_SIZE) {
            [[unroll]] for (uint it = 0; it < TILE_SIZE; it++) {
                const uint xi = inputOffset + i + it;
                const float16_t xScale = x[xi].d;
                [[unroll]] for (uint j = 0; j < Q80_Q40_BLOCK_SIZE / 2; j++) {
                    xTemp[j * 2]     = float16_t(x[xi].qs[j]);
                    xTemp[j * 2 + 1] = float16_t(x[xi].qs[j + Q80_Q40_BLOCK_SIZE / 2]);
                }

                [[unroll]] for (uint dt = 0; dt < TILE_SIZE; dt++) {
                    const uint wi = (d + dt) * inputSizeX + (i + it);
                    const BlockQ40 wBlock = weight[wi];

                    float16_t s = float16_t(0.0f);
                    [[unroll]] for (uint j = 0; j < Q80_Q40_BLOCK_SIZE / 2; j++) {
                        s += (
                            xTemp[j * 2]     * (float16_t(wBlock.qs[j] & 0xF) - float16_t(8.0f)) +
                            xTemp[j * 2 + 1] * (float16_t(wBlock.qs[j] >>  4) - float16_t(8.0f))
                        );
                    }
                    sums[threadIndex * TILE_SIZE + dt] += s * xScale * wBlock.d;
                }
            }
        }

        barrier();
        memoryBarrierShared();

        [[unroll]] for (uint i = N_THREADS / 2; i > 0; i >>= 1) {
            for (uint dt = 0; dt < TILE_SIZE; dt++) {
                if (threadIndex < i) {
                    sums[threadIndex * TILE_SIZE + dt] += sums[(threadIndex + i) * TILE_SIZE + dt];
                }
            }
            barrier();
        }

        if (threadIndex < TILE_SIZE) {
            y[outputOffset + d + threadIndex] = float(sums[threadIndex]);
        }

        barrier();
    }
}
